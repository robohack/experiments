#include <float.h>
#include <limits.h>
#include <stdlib.h>
#include <unistd.h>

double Rand_to_Float(uintmax_t n);
long random_at_most(long max);
double drand_rng(unsigned int N);

/*
 * The most even distribution of random numbers between 0.0 and 1.0 can be had
 * by passing a random integer, e.g.:
 *
 *	srand(time_seed());
 * 	double rv = Rand_to_Float(rand());
 */
double
Rand_to_Float(uintmax_t n)
{
	double value;
	const uintmax_t maxRange = 1LU << DBL_MANT_DIG; /* max integer in a double */

	n &= maxRange - 1;
	value = (double) n * 1.0 / (double) maxRange;

	return value;
}


// from:  https://stackoverflow.com/a/6852396
//
// Returns a random (long) integer in the closed interval [0..max]
//
long
random_at_most(long max)		// Assumes 0 <= max <= RAND_MAX
{
	// max <= RAND_MAX < ULONG_MAX, so this is okay.
	unsigned long num_bins = (unsigned long) max + 1;
	unsigned long num_rand = (unsigned long) RAND_MAX + 1;
	unsigned long bin_size = num_rand / num_bins;
	unsigned long defect   = num_rand % num_bins;
	long x;

	do {
		x = random();
	} while (num_rand - defect <= (unsigned long) x);   // This is carefully written not to overflow

	// Truncated division is intentional
	return x / (long) bin_size;
}

/*
 * drand_rng() - return a random number in the range 0..N (closed? open?)
 *
 * - assuming N is "much less" than RAND_MAX, and also assuming N is less than
 *   UINT_MAX + 1 (the maximum entropy that can be passed to srand())
 *
 * see http://c-faq.com/lib/randrange.html
 *
 * rand() is stupid -- it should have returned unsigned int and taken a range
 * parameter up to RAND_MAX
 *
 * Shifting the range to M..N would require the equivalent of:
 *
 *	M + rand() / (RAND_MAX / (N - M + 1) + 1)
 *
 * XXX maybe this should use random(3), since on NetBSD at least the manual says
 * "rand(3) produces a much less random sequence....  All the bits generated by
 * random() are usable."  See trand.c for random_at_most() using random(3).
 * Note rand(3) is ANSI-C/POSIX, while random(3) is 4.2BSD and not in POSIX
 * until 2008.  There's also arc4random_uniform(3) which is this, exactly, but
 * truly, always, random.
 */
double
drand_rng(unsigned int N)
{
	unsigned int x = (RAND_MAX + 1u) / N;
	unsigned long y = x * N;
	double r;

#if 0
	/* xxx only needed if RAND_MAX is at or near INT_MAX */
	static_assert(sizeof(unsigned long) > sizeof(unsigned int));
#endif

	/* xxx probably only needed if N is "close" to RAND_MAX, and ((RAND_MAX + 1) % N != 0) */
	do {
		r = rand();
	} while (r >= y);

	return r / x;
}
